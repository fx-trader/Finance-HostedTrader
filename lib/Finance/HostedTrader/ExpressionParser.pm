package Finance::HostedTrader::ExpressionParser;

# ABSTRACT: Finance::HostedTrader::ExpressionParser - Utility object to calculate indicators/signals based on complex expressions
#Maybe one day convert this to lex/bison
#http://www.scribd.com/doc/8669780/Lex-yacc-Tutoriala

use strict;
use warnings;

use Date::Manip;
use Statistics::Descriptive;
use Log::Log4perl qw(:easy);
use List::Util;
use Finance::HostedTrader::Datasource;
use Finance::HostedTrader::Provider;

# See http://search.cpan.org/~jtbraun/Parse-RecDescent-1.967013/lib/Parse/RecDescent.pm#Precompiling_parsers
# For details of how to generate Grammar.pm.
# In a nutshell, it needs to be generated using the same runtime version of Parse::RecDescent, and can be generated by running:
# perl -MParse::RecDescent - /src/Finance-HostedTrader/lib/Finance/HostedTrader/grammar Finance::HostedTrader::ExpressionParser::Grammar
use Finance::HostedTrader::ExpressionParser::Grammar;

my ( %TIMEFRAMES, %INDICATORS, @VALUES );

sub getID {
    my $type = shift;
    my @rv = ();
    my $key = scalar(@VALUES);

    push @VALUES, { type => $type, items => [] };

    while ( defined(my $item = shift) ) {
        $INDICATORS{$item} = scalar( keys %INDICATORS )
          unless exists $INDICATORS{$item};
        push @{ $VALUES[$key]->{items} }, $item;
    }
    return $key;
}

sub setSignalTimeframe {
    my ($sig, $tf) = @_;

    my $key = join (' ', @$sig);
    $TIMEFRAMES{$key} = $tf;
}

#$::RD_TRACE=1;
$::RD_HINT   = 1;
$::RD_WARN   = 1;
$::RD_ERRORS = 1;

sub new {
    my ( $class, $ds ) = @_;

# Sample function calls
# macddiff( dataset, shortperiodema, longperiodema, signalema), macddiff(12,26,9)

    my $parser    = Finance::HostedTrader::ExpressionParser::Grammar->new();

    if (!Log::Log4perl->initialized()) {
        if ( -r "/etc/fxtrader/fxtrader.log.conf" ) {
            Log::Log4perl->init("/etc/fxtrader/fxtrader.log.conf");
        }
    }

    my $self = {
        '_parser' => $parser,
        '_ds'       => ( $ds ? $ds : Finance::HostedTrader::Datasource->new() ),
        '_cache'    => {}, # caches parsing of expressions
        '_logger'   => Log::Log4perl::get_logger(),
    };

    return bless( $self, $class );
}

=method C<getDescriptiveStatisticsData>

    Returns descriptive statistic about returns.
    See https://miltonfmr.com/applied-statistics-futures-markets/

=cut

sub getDescriptiveStatisticsData {
    my ($self, $args) = @_;

    my @good_args = qw(provider timeframe symbol max_loaded_items start_period end_period item_count expression percentiles weekdays inner_sql_filter);
    foreach my $key (keys %$args) {
        $self->{_logger}->logconfess("invalid arg in getStatisticsData: $key") unless grep { /$key/ } @good_args;
    }

    my %stat_args = %{ $args };
    my $percentiles = delete $stat_args{percentiles} // '75,80,85,90,95,99';
    my $expression = delete $stat_args{expression} // '(close-open)/open';
    $stat_args{expression} = "datetime,$expression";

    my $data    = $self->getIndicatorData( \%stat_args );
    my $stat    = Statistics::Descriptive::Full->new();
    my @period_returns  = map {  $_->[1] } @{ $data->{data} };
    delete $data->{data};
    $stat->add_data( @period_returns );

    $data->{stats}  = {
            count               => $stat->count,
            mean                => $stat->mean,
            sum                 => $stat->sum,
            variance            => $stat->variance,
            standard_deviation  => $stat->standard_deviation,
            min                 => $stat->min,
            max                 => $stat->max,
            range               => $stat->max - $stat->min,
            skewness            => $stat->skewness,
            kurtosis            => $stat->kurtosis,
            median              => $stat->median,
        };

    #my @bins = qw/-0.03 -0.025 -0.02 -0.015 -0.01 -0.005 0 0.005 0.01 0.015 0.02 0.025 0.3/;
    #$data->{frequency_distributions} = $stat->frequency_distribution_ref( \@bins );

    #my %cumulative_distributions;
    #my $cumulative_total = 0;
    #foreach my $item ( sort { $a <=> $b } keys %{ $data->{frequency_distributions } } ) {
    #    $cumulative_total += $data->{frequency_distributions}{$item};
    #    $cumulative_distributions{$item}  = $cumulative_total;
    #}
    #$data->{cumulative_frequency_distributions} = \%cumulative_distributions;
    $data->{percentiles} =  { map { $_ => scalar($stat->percentile($_)) } split(/,/, $percentiles) };

    $data->{average_returns}{overall}   = $data->{stats}{mean};
    my $stat_negative_returns = Statistics::Descriptive::Full->new();
    $stat_negative_returns->add_data( grep { $_ < 0 } @period_returns );
    my $stat_positive_returns = Statistics::Descriptive::Full->new();
    $stat_positive_returns->add_data( grep { $_ > 0 } @period_returns );
    $data->{average_returns}{positive}  = $stat_positive_returns->mean;
    $data->{average_returns}{negative}  = $stat_negative_returns->mean;

    return $data;
}

=method C<getIndicatorData>

args

timeframe
expression
symbol
max_loaded_items
end_period
item_count
weekdays

=cut

sub getIndicatorData {
    my ( $self, $args ) = @_;

    my $sql = $self->_getIndicatorSql(%$args);
    $self->{_logger}->debug($sql);

    my $dbh = $self->{_ds}->dbh;
    my $data = $dbh->selectall_arrayref($sql) or $self->{_logger}->logconfess($DBI::errstr);

    return { data => $data, sql => $sql } if ($args->{sqldebug});
    return { data => $data };
}

=method C<getSignalData>
See L</getIndicatorData> for list of arguments.
=cut
sub getSignalData {
    my ( $self, $args ) = @_;
    my $sql = $self->_getSignalSql($args);

    $self->{_logger}->debug($sql);

    my $dbh = $self->{_ds}->dbh;
    my $data = $dbh->selectcol_arrayref($sql) || $self->{_logger}->logconfess( $DBI::errstr . $sql );

    return { data => $data, sql => $sql } if ($args->{sqldebug});
    return { data => $data, };
}

=method C<getSystemData>
=cut
sub getSystemData {
    my ( $self, $a ) = @_;

    my %args = %{ $a };

    $args{expr} = delete $args{enter};
    my $exitSignal = delete $args{exit};
    $args{fields} = "'ENTRY' AS Action, datetime, close";

    #TODO, limit nbitems not done here
    my $sql_entry = $self->_getSignalSql(\%args);
    $args{expr} = $exitSignal;
    $args{fields} = "'EXIT' AS Action, datetime, close";
    my $sql_exit  = $self->_getSignalSql(\%args);


    my $sql = $sql_entry . ' UNION ALL ' . $sql_exit . ' ORDER BY datetime';
    $self->{_logger}->debug($sql);

    my $dbh = $self->{_ds}->dbh;
    my $data = $dbh->selectall_arrayref($sql) or $self->{_logger}->logconfess( $DBI::errstr . $sql );
    return $data;
}

sub _getSignalSql {
my ($self, $args) = @_;

    my @obsolete_arg_names  = qw(tf expr maxLoadedItems startPeriod endPeriod numItems fields);
    $self->log_obsolete_argument_names(\@obsolete_arg_names, $args);
    my @good_args           = qw(provider timeframe expression symbol max_loaded_items start_period end_period item_count fields);

    foreach my $key (keys %$args) {
        $self->{_logger}->logconfess("invalid arg in _getSignalSql: $key") unless grep { /$key/ } @good_args, @obsolete_arg_names;
    }

    my $tf_name = $args->{timeframe} || $args->{tf} || 'day';
    my $default_tf = $self->{_ds}->cfg->timeframes->getTimeframeID($tf_name);
    $self->{_logger}->logconfess( "Could not understand timeframe " . ( $tf_name ) ) if (!$default_tf);
    my $expr   = $args->{expression} || $args->{expr}   || $self->{_logger}->logconfess("No expression set for signal");
    $expr = lc($expr);
    my $symbol = $args->{symbol} || $self->{_logger}->logconfess("No symbol set");
    my $maxLoadedItems = $args->{max_loaded_items} || $args->{maxLoadedItems} || 10_000_000_000;
    my $startPeriod = $args->{start_period} || $args->{startPeriod} || '0001-01-01 00:00:00';
    my $endPeriod = $args->{end_period} || $args->{endPeriod} || '9999-12-31 23:59:59';
    my $fields = $args->{fields} || 'datetime';
    my $provider = $args->{provider};

    my $data_provider = $self->{_ds}->cfg->provider($provider);

    my $itemCount = $args->{item_count} || $args->{numItems} || $maxLoadedItems;

    %TIMEFRAMES = ();
    %INDICATORS = ();
    @VALUES     = ();
    my $results = $self->{_parser}->start_signal( $expr );
    #use Data::Dumper;
    #print "TIMEFRAMES = " . Dumper(\%TIMEFRAMES);
    #print "INDICATORS = " . Dumper(\%INDICATORS);
    #print "VALUES = " . Dumper(\@VALUES);
    #print "results = " . Dumper(\$results);
    #exit;

    $self->{_logger}->logdie("Syntax error in signal \n\n$expr\n") unless ( defined($results) );

    my @all_timeframes_sql = ();
    my @timeframes_sql_glue = ();

    my $max_timeframe_requested = List::Util::max(values %TIMEFRAMES) || $default_tf;
    my $min_timeframe_requested = List::Util::min(values %TIMEFRAMES) || $default_tf;
    my $cfg = $self->{_ds}->cfg;
    my $common_timeframe_pattern = $cfg->timeframes->getTimeframeFormat($cfg->timeframes->getTimeframeName($max_timeframe_requested));

    foreach my $result (@$results) {

        my $result_str;
        if (!ref($result)) {
            push @timeframes_sql_glue, $result;
            next;
        }
        my $tf = $TIMEFRAMES{join(' ', @$result)} || $default_tf;
        my @fields;

        foreach my $result_signal (@$result) {
            if ($result_signal =~ /^[0-9]+$/) {
                my $value = $VALUES[$result_signal];
                my $str;

                push @fields, map { "$_ AS T$INDICATORS{$_}" } @{$value->{items}};

                if ( $value->{type} eq 'crossoverup' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " <= T" . $INDICATORS{$value->{items}->[1]} . " AND T" . $INDICATORS{$value->{items}->[2]} . " > T" . $INDICATORS{$value->{items}->[3]} . ")";
                } elsif ( $value->{type} eq 'crossoverdown' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " >= T" . $INDICATORS{$value->{items}->[1]} . " AND T" . $INDICATORS{$value->{items}->[2]} . " < T" . $INDICATORS{$value->{items}->[3]} . ")";
                } elsif ( $value->{type} eq 'cmpop>=' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " >= T" . $INDICATORS{$value->{items}->[1]} . ")";
                } elsif ( $value->{type} eq 'cmpop>' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " > T" . $INDICATORS{$value->{items}->[1]} . ")";
                } elsif ( $value->{type} eq 'cmpop<=' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " <= T" . $INDICATORS{$value->{items}->[1]} . ")";
                } elsif ( $value->{type} eq 'cmpop<' ) {
                    $str = "(T" . $INDICATORS{$value->{items}->[0]} . " < T" . $INDICATORS{$value->{items}->[1]} . ")";
                } else {
                    die("Invalid grammar. $value->{type}");
                }
                $result_str .= $str;
            } else {
                $result_str .= ' ' . $result_signal . ' ';
            }
        }

        my %unique_fields = map { $_ => undef } @fields;

        my $select_fields = join( ', ', keys %unique_fields );
        $select_fields = ',' . $select_fields if ($select_fields);

        my $WHERE_FILTER = " WHERE datetime <= '$endPeriod'";
        $WHERE_FILTER .= ' AND dayofweek(datetime) <> 1' if ( $tf != 604800 );
        my $ORDERBY_CLAUSE='';
        $ORDERBY_CLAUSE='ORDER BY datetime ASC';

        my $tableName = $data_provider->getTableName($symbol, $tf);

        my $tf_sql = qq(
(
SELECT $fields, $common_timeframe_pattern AS COMMON_TIMEFRAME_PATTERN FROM (
SELECT $fields FROM (
SELECT *$select_fields
FROM (
    SELECT * FROM ${tableName}
    $WHERE_FILTER
    ORDER BY datetime DESC
    LIMIT $maxLoadedItems
) AS T_INNER
ORDER BY datetime ASC
LIMIT 18446744073709551615 -- See https://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/
) AS T_OUTER
WHERE $result_str AND datetime <='$endPeriod'
) AS DT
$ORDERBY_CLAUSE
LIMIT 18446744073709551615 -- See https://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/
) AS SIGNALS_TF_$tf

);

        push @all_timeframes_sql,  {sql => $tf_sql, tf => $tf};
    }

    #print Dumper(\@all_timeframes_sql);
    #print Dumper(\@timeframes_sql_glue);
    my %unique_timeframes_sql_glue = map { $_ => 1 } @timeframes_sql_glue;
    if (scalar(keys(%unique_timeframes_sql_glue)) > 1) {
        # When using a signal expression with more than one timeframe,
        # This is valid:
        #   4hour(close > ema(close,21)) and 2hour(close > ema(close,21)) and hour(close > ema(close,21))
        # This is not:
        #   4hour(close > ema(close,21)) and 2hour(close > ema(close,21)) or hour(close > ema(close,21))

        # In other words, currently, if a signal expression has multiple timeframes, the all need to be 'and' or 'or'.
        # I haven't figured out how to write a query to mix and match them.
        # This validates for that condition and returns an appropriate error.

        $self->{_logger}->logdie("In a multiple timeframe signal expression, all boolean operators between timeframe functions need to be the same. This is a limitation of the API.");
    }

    my $sql;
    my $where_clause;
    if (!@timeframes_sql_glue) {
        my $leftop = shift(@all_timeframes_sql);
        $sql = "SELECT $fields FROM $leftop->{sql}";
        $where_clause = "WHERE datetime >= '$startPeriod'";
    } else {
        $sql = "SELECT SIGNALS_TF_$min_timeframe_requested.datetime FROM\n";
        $where_clause = "WHERE SIGNALS_TF_$min_timeframe_requested.datetime >= '$startPeriod'";
        if (scalar(@all_timeframes_sql) < 2) {
            # This condition should never happen. If it does,
            # there was an error filling up the internal data structures
            # that support signal calculations
            $self->{_logger}->logdie("missing data, internal error");
        }

        my $leftop = shift(@all_timeframes_sql);
        $sql .= $leftop->{sql};

        while ( my $op = shift(@timeframes_sql_glue) ) {
            my $rightop = shift(@all_timeframes_sql);

            if ($op eq 'and') {
                $sql .= "\nINNER JOIN\n" . $rightop->{sql} . " ON SIGNALS_TF_$leftop->{tf}.COMMON_TIMEFRAME_PATTERN = SIGNALS_TF_$rightop->{tf}.COMMON_TIMEFRAME_PATTERN";
            } elsif ($op eq 'or') {
                $sql .= "\nUNION ALL\n" . $rightop->{sql};
            } else {
                # This can't really be reached because the grammar only allows operators 'and', 'or'.
                $self->{_logger}->logconfess("Unknown operator: $op");
            }

        }
    }
    $sql .= " $where_clause ORDER BY datetime DESC limit $itemCount";
    return $sql;
}

sub log_obsolete_argument_names {
    use Devel::StackTrace;
    my ($self, $obsolete_arg_names, $args) = @_;

    my $l = $self->{_logger};
    my $trace = Devel::StackTrace->new();

    foreach my $arg_name (@$obsolete_arg_names) {

        if ( exists ($args->{$arg_name}) ) {
            $l->warn("OBSOLETE ARGUMENT USED: $arg_name");
            $l->warn($trace->as_string);
        }

    }
}

sub _getIndicatorSql {
    my ($self, %args) = @_;
    my ( $result );

    my @obsolete_arg_names  = qw(tf fields maxLoadedItems endPeriod numItems);
    $self->log_obsolete_argument_names(\@obsolete_arg_names, \%args);
    my @good_args           = qw(provider timeframe expression symbol max_loaded_items start_period end_period item_count inner_sql_filter weekdays);

    foreach my $key (keys %args) {
        $self->{_logger}->logconfess("invalid arg in getIndicatorData: $key") unless grep { /$key/ } @good_args, @obsolete_arg_names;
    }

    my $tf_name = $args{timeframe} || $args{tf} || 'day';
    my $tf = $self->{_ds}->cfg->timeframes->getTimeframeID($tf_name);
    $self->{_logger}->logconfess( "Could not understand timeframe " . ( $tf_name ) ) if (!$tf);
    my $maxLoadedItems = $args{max_loaded_items} || $args{maxLoadedItems} || 10_000_000_000;;
    my $displayStartDate   = $args{start_period} || $args{start_period} || '0001-01-01';
    my $displayEndDate   = $args{end_period} || $args{end_period} || '9999-12-31';
    my $expr      = $args{expression} || $args{fields}          || $self->{_logger}->logconfess("No indicator expression set");
    $expr = lc($expr);
    my $symbol    = $args{symbol}          || $self->{_logger}->logconfess("No symbol set for indicator");
    my $itemCount = $args{item_count} || $args{numItems} || 10_000_000;
    my $sqlFilter = $args{inner_sql_filter} // '';
    my $provider  = $args{provider};

    my $data_provider = $self->{_ds}->cfg->provider($provider);

    #TODO: Refactor the parser bit so that it can be called independently. This will be usefull to validate expressions before running them.
    $result     = $self->{_parser}->start_indicator($expr);

    #TODO: Need a more meaningfull error message describing what's wrong with the given expression
    $self->{_logger}->logdie("Syntax error in indicator \n\n$expr\n")
        unless ( defined($result) );

    my $WHERE_FILTER = "WHERE datetime >= '$displayStartDate' AND datetime <= '$displayEndDate'";
    $WHERE_FILTER .= " AND ($sqlFilter)" if ($sqlFilter);
#    $WHERE_FILTER .= ' AND dayofweek(datetime) <> 1' if ( $tf != 604800 );

    my $tableName = $data_provider->getTableName($symbol, $tf);
    my $sql = qq(
SELECT * FROM (
SELECT $result FROM (
  SELECT * FROM $tableName
  $WHERE_FILTER
  ORDER BY datetime DESC
  LIMIT $maxLoadedItems
) AS R
ORDER BY datetime ASC
LIMIT 18446744073709551615 -- See https://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/
) AS LIMIT_ROWS
ORDER BY datetime DESC
LIMIT $itemCount
);

return $sql;

}



=method C<checkSignal>
Check wether a given signal occurred in a given period of time
=cut
sub checkSignal {
    my ( $self, $args ) = @_;

    my @good_args = qw(provider expr symbol tf maxLoadedItems period simulatedNowValue);

    foreach my $key (keys %$args) {
        $self->{_logger}->logconfess("invalid arg in checkSignal: $key") unless grep { /$key/ } @good_args;
    }

    my $expr = $args->{expr} || $self->{_logger}->logconfess("expr argument missing in checkSignal");
    my $symbol = $args->{symbol} || $self->{_logger}->logconfess("symbol argument missing in checkSignal");
    my $timeframe = $args->{tf} || $self->{_logger}->logconfess("timeframe argument missing in checkSignal");
    my $maxLoadedItems = $args->{maxLoadedItems} || -1;
    my $period = $args->{period} || 3600;
    my $nowValue = $args->{simulatedNowValue} || 'now';
    my $provider = $args->{provider};

    my $startPeriod = UnixDate(DateCalc($nowValue, '- '.$period."seconds"), '%Y-%m-%d %H:%M:%S');
    my $endPeriod = UnixDate($nowValue, '%Y-%m-%d %H:%M:%S');
    my $signal_result = $self->getSignalData(
        {
            'provider'        => $provider,
            'expr'            => $expr,
            'symbol'          => $symbol,
            'tf'              => $timeframe,
            'maxLoadedItems'  => $maxLoadedItems,
            'startPeriod'     => $startPeriod,
            'endPeriod'       => $endPeriod,
            'numItems'        => 1,
        }
    );
    my $data = $signal_result->{data};

    return $data->[0] if defined($data);
}
1;
